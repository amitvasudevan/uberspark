(*
	uberSpark external binary generation utilities interface
	author: amit vasudevan (amitvasudevan@acm.org)
*)

open Ustypes
open Usconfig
open Uslog
open Usosservices

module Usextbinutils =
	struct

	let tool_pp = "gcc" ;;
	let tool_cc = "gcc" ;;
	let tool_ld = "ld" ;;
	let tool_ar = "ar" ;;
	let tool_objcopy = "objcopy" ;;
		
	let usextbinutils_tag = "Usextbinutils" ;;
			
	let hashtbl_keys h = Hashtbl.fold (fun key _ l -> key :: l) h [];;
	
	let generate_linker_script 
		(fname : string)
		(binary_origin : int)
		(binary_size : int)
		(sections_hashtbl : (int, Ustypes.section_info_t) Hashtbl.t) 
		 		: string =
		
		let linker_script_filename = (fname ^ ".lscript") in
		let oc = open_out linker_script_filename in
			Printf.fprintf oc "\n/* autogenerated uberSpark linker script */";
			Printf.fprintf oc "\n/* author: amit vasudevan (amitvasudevan@acm.org) */";
			Printf.fprintf oc "\n";
			Printf.fprintf oc "\n";
			Printf.fprintf oc "\nOUTPUT_ARCH(\"i386\")";
			Printf.fprintf oc "\n";
			Printf.fprintf oc "\n";

(*			Printf.fprintf oc "\nMEMORY";
			Printf.fprintf oc "\n{";
			Printf.fprintf oc "\n %s (%s) : ORIGIN = 0x%08x, LENGTH = 0x%08x"
						("mem_binary")
						( "rw" ^ "ail") 
						(binary_origin) 
						(binary_size);
			Printf.fprintf oc "\n}";
			Printf.fprintf oc "\n";
*)

			Printf.fprintf oc "\nMEMORY";
			Printf.fprintf oc "\n{";
	
			let keys = List.sort compare (hashtbl_keys sections_hashtbl) in				
			List.iter (fun key ->
			    let x = Hashtbl.find sections_hashtbl key in
					(* new section memory *)
					Printf.fprintf oc "\n %s (%s) : ORIGIN = 0x%08x, LENGTH = 0x%08x"
						("mem_" ^ x.f_name)
						( "rw" ^ "ail") (x.usbinformat.f_addr_start) (x.usbinformat.f_size);
					()
			) keys ;

(*
			Printf.fprintf oc "\n %s (%s) : ORIGIN = 0x%08x, LENGTH = 0x%08x"
					("mem_binary")
					( "rw" ^ "ail") 
					(binary_origin) 
					(binary_size);
*)	
			Printf.fprintf oc "\n}";
			Printf.fprintf oc "\n";
		
				
			Printf.fprintf oc "\nSECTIONS";
			Printf.fprintf oc "\n{";
			Printf.fprintf oc "\n";
	
			let keys = List.sort compare (hashtbl_keys sections_hashtbl) in				

			let i = ref 0 in 			
			while (!i < List.length keys) do
			  let key = (List.nth keys !i) in
				let x = Hashtbl.find sections_hashtbl key in
					(* new section *)
			    if(!i == (List.length keys) - 1 ) then 
						begin
							Printf.fprintf oc "\n %s : {" x.f_name;
							(*Printf.fprintf oc "\n	. = ALIGN(0x%08x);" x.usbinformat.f_aligned_at;*)
							Printf.fprintf oc "\n	%s_START_ADDR = .;" x.f_name;
							List.iter (fun subsection ->
								    Printf.fprintf oc "\n *(%s)" subsection;
							) x.f_subsection_list;
							(* Printf.fprintf oc "\n . = ORIGIN(mem_binary) + LENGTH(mem_binary) - 1;";*)
							Printf.fprintf oc "\n . = ORIGIN(%s) + LENGTH(%s) - 1;" ("mem_" ^ x.f_name) ("mem_" ^ x.f_name);
							Printf.fprintf oc "\n BYTE(0xAA)";
							Printf.fprintf oc "\n	%s_END_ADDR = .;" x.f_name;
							(*Printf.fprintf oc "\n	} >mem_binary =0x9090";*)
					    Printf.fprintf oc "\n	} >%s =0x9090" ("mem_" ^ x.f_name);
					    Printf.fprintf oc "\n";
						end
					else
						begin
							Printf.fprintf oc "\n %s : {" x.f_name;
							(* Printf.fprintf oc "\n	. = ALIGN(0x%08x);" x.usbinformat.f_aligned_at; *)
							Printf.fprintf oc "\n	%s_START_ADDR = .;" x.f_name;
							List.iter (fun subsection ->
								    Printf.fprintf oc "\n *(%s)" subsection;
							) x.f_subsection_list;
							(* Printf.fprintf oc "\n . = ALIGN(0x%08x);" x.usbinformat.f_pad_to; *) 
							Printf.fprintf oc "\n . = ORIGIN(%s) + LENGTH(%s) - 1;" ("mem_" ^ x.f_name) ("mem_" ^ x.f_name);
							Printf.fprintf oc "\n BYTE(0xAA)";
							Printf.fprintf oc "\n	%s_END_ADDR = .;" x.f_name;
					    (*Printf.fprintf oc "\n	} >mem_binary =0x9090";*)
					    Printf.fprintf oc "\n	} >%s =0x9090" ("mem_" ^ x.f_name);
					    Printf.fprintf oc "\n";
						end
					;
    	
				i := !i + 1;
			done;
						
			Printf.fprintf oc "\n";
			Printf.fprintf oc "\n	/* this is to cause the link to fail if there is";
			Printf.fprintf oc "\n	* anything we didn't explicitly place.";
			Printf.fprintf oc "\n	* when this does cause link to fail, temporarily comment";
			Printf.fprintf oc "\n	* this part out to see what sections end up in the output";
			Printf.fprintf oc "\n	* which are not handled above, and handle them.";
			Printf.fprintf oc "\n	*/";
			Printf.fprintf oc "\n	/DISCARD/ : {";
			Printf.fprintf oc "\n	*(*)";
			Printf.fprintf oc "\n	}";
			Printf.fprintf oc "\n}";
			Printf.fprintf oc "\n";
																																																																																																																									
			close_out oc;
			(linker_script_filename)
	;;
			
			
			
	let preprocess 
			pp_inputfilename pp_outputfilename pp_includedirs_list pp_defines_list =
			let pp_cmdline = ref [] in
				pp_cmdline := !pp_cmdline @ [ "-E" ];
				pp_cmdline := !pp_cmdline @ [ "-P" ];
				List.iter (fun x -> 
						pp_cmdline := !pp_cmdline @ [ "-I" ] @ [ x ]
						) pp_includedirs_list;
				List.iter (fun x -> 
						pp_cmdline := !pp_cmdline @ [ "-D" ] @ [ x ]
						) pp_defines_list;
				pp_cmdline := !pp_cmdline @ [ pp_inputfilename ];
				pp_cmdline := !pp_cmdline @ [ "-o" ];
				pp_cmdline := !pp_cmdline @ [ pp_outputfilename ];
				let (pp_retval, _, _) =
						Usosservices.exec_process_withlog 
					tool_pp !pp_cmdline true usextbinutils_tag in
		(pp_retval, pp_outputfilename)
	;;
				
			
	let compile_cfile cc_inputfilename cc_outputfilename cc_includedirs_list
		cc_defines_list =  
			let cc_cmdline = ref [] in
				cc_cmdline := !cc_cmdline @ [ "-c" ];
				cc_cmdline := !cc_cmdline @ [ "-m32" ];
				cc_cmdline := !cc_cmdline @ [ "-fno-common" ];
				List.iter (fun x -> 
						cc_cmdline := !cc_cmdline @ [ "-I" ] @ [ x ]
						) cc_includedirs_list;
				List.iter (fun x -> 
						cc_cmdline := !cc_cmdline @ [ "-D" ] @ [ x ]
						) cc_defines_list;
				cc_cmdline := !cc_cmdline @ [ cc_inputfilename ];
				cc_cmdline := !cc_cmdline @ [ "-o" ];
				cc_cmdline := !cc_cmdline @ [ cc_outputfilename ];
				let (cc_pestatus, cc_pesignal, _) =
						Usosservices.exec_process_withlog 
					tool_cc !cc_cmdline true usextbinutils_tag in
				(cc_pestatus, cc_pesignal, cc_outputfilename)
	;;


	let link_uobj uobj_ofile_list uobj_libdirs_list uobj_libs_list 
			uobj_linker_script uobj_bin_name = 
			let ld_cmdline = ref [] in
				ld_cmdline := !ld_cmdline @ [ "--oformat" ];
				ld_cmdline := !ld_cmdline @ [ "elf32-i386" ];
				ld_cmdline := !ld_cmdline @ [ "-T" ];
				ld_cmdline := !ld_cmdline @ [ uobj_linker_script ]; 
				List.iter (fun x -> ld_cmdline := !ld_cmdline @ [ (x^".o") ]) uobj_ofile_list; 
				ld_cmdline := !ld_cmdline @ [ "-o" ];
				ld_cmdline := !ld_cmdline @ [ uobj_bin_name ];
				List.iter (fun x -> ld_cmdline := !ld_cmdline @ [ ("-L"^x) ]) uobj_libdirs_list; 
				ld_cmdline := !ld_cmdline @ [ "--start-group" ];
				List.iter (fun x -> ld_cmdline := !ld_cmdline @ [ ("-l"^x) ]) uobj_libs_list; 
				ld_cmdline := !ld_cmdline @ [ "--end-group" ];
				let (ld_pestatus, ld_pesignal, _) = 
						Usosservices.exec_process_withlog 
						tool_ld !ld_cmdline true usextbinutils_tag in
				(ld_pestatus, ld_pesignal) 
	;;


	let mkbin uobj_input_filename uobj_output_filename = 
			let objcopy_cmdline = ref [] in
				objcopy_cmdline := !objcopy_cmdline @ [ "-I" ];
				objcopy_cmdline := !objcopy_cmdline @ [ "elf32-i386" ];
				objcopy_cmdline := !objcopy_cmdline @ [ "-O" ];
				objcopy_cmdline := !objcopy_cmdline @ [ "binary" ];
				objcopy_cmdline := !objcopy_cmdline @ [ uobj_input_filename ];
				objcopy_cmdline := !objcopy_cmdline @ [ uobj_output_filename ];
				let (objcopy_pestatus, objcopy_pesignal, _) = 
						Usosservices.exec_process_withlog 
						tool_objcopy !objcopy_cmdline true usextbinutils_tag in
				(objcopy_pestatus, objcopy_pesignal) 
	;;



	let mklib lib_ofile_list lib_name = 
			let ar_cmdline = ref [] in
				ar_cmdline := !ar_cmdline @ [ "-rcs" ];
				ar_cmdline := !ar_cmdline @ [ lib_name ]; 
				List.iter (fun x -> ar_cmdline := !ar_cmdline @ [ (x^".o") ]) lib_ofile_list; 
				let (ar_pestatus, ar_pesignal, _) = 
						Usosservices.exec_process_withlog 
						tool_ar !ar_cmdline true usextbinutils_tag in
				(ar_pestatus, ar_pesignal) 
	;;



	let mkbin_from_cfile p_cfilename p_hashtbl_lscript_sections p_binfilename p_binorigin p_binsize = 
		let retval = ref false in 
		let (pestatus, pesignal, cc_outputfilename) = 
			compile_cfile p_cfilename (p_cfilename ^ ".o") 
				(Usconfig.get_std_incdirs ())	(Usconfig.get_std_defines ()) in
			if (pesignal == true) || (pestatus != 0) then
				begin
						Uslog.logf usextbinutils_tag Uslog.Error "in compiling %s!" p_cfilename;
						retval := false;
				end
			else
				begin
						retval := true;
						Uslog.logf usextbinutils_tag Uslog.Info "Compiled %s successfully" p_cfilename;
				end
			;

			let lscript = generate_linker_script  
				(p_cfilename) p_binorigin (p_binsize) p_hashtbl_lscript_sections in

			(* build binary elf *)
			let libdirs_list = ref [] in
			let libs_list = ref [] in
			let (pestatus, pesignal) = 
					(link_uobj  
						[p_cfilename]
						!libdirs_list !libs_list
						lscript (p_binfilename ^ ".elf")
					) in
				if (pesignal == true) || (pestatus != 0) then
					begin
							Uslog.logf usextbinutils_tag Uslog.Error "in building binary!";
							retval := false;
					end
				else
					begin
							retval := true;
							Uslog.logf usextbinutils_tag Uslog.Info "Built binary";
					end
				;

			(* make flat form binary *)
			let (pestatus, pesignal) = 
			(mkbin
				  (p_binfilename ^ ".elf")
					(p_binfilename ^ ".bin")
			) in
			if (pesignal == true) || (pestatus != 0) then
				begin
						Uslog.logf usextbinutils_tag Uslog.Error "generating flat-form binary!";
						retval := false;
				end
			else
				begin
						retval := true;
						Uslog.logf usextbinutils_tag Uslog.Info "Built flat-form binary";
				end
			;

		(!retval)
	;;


																							
	let test_func () =
		(true)
	;;

	end