(*===========================================================================*)
(*===========================================================================*)
(* uberSpark manifest interface implementation *)
(*	 author: amit vasudevan (amitvasudevan@acm.org) *)
(*===========================================================================*)
(*===========================================================================*)

open Yojson


(*---------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------*)
(* type definitions *)
(*---------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------*)

(* uberspark manifest json node type *)
type json_node_uberspark_manifest_t =
{
	mutable namespace : string list;
	mutable version_min   : string;
	mutable version_max   : string;
};;



(*---------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------*)
(* interface definitions *)
(*---------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------*)


let json_list_to_string_list
	json_list = 
	
	let ret_str_list = ref [] in
		List.iter (fun (x) ->
			ret_str_list := !ret_str_list @ [ (Yojson.Basic.Util.to_string x) ];
		) json_list;

	(!ret_str_list)
;;


let json_node_pretty_print_to_string json_node 
	: string =
    (Yojson.Basic.pretty_to_string json_node)
;;


let json_node_update key new_value json_node 
	: (bool * Yojson.Basic.t) =
    let updated = ref false in
    let as_obj = Yojson.Basic.Util.to_assoc json_node in
    let g = List.map begin function
        | (this_key, _inner) when this_key = key -> updated := true; (this_key, new_value)
        | otherwise -> otherwise
      end
        as_obj
    in
    if !updated then (true, `Assoc g) else (false, `Assoc g)
;;





(*--------------------------------------------------------------------------*)
(* read manifest file into json *)
(* note: this does not check if this is a valid uberspark manifest; only checked *)
(* if it is a valid json file *)
(*--------------------------------------------------------------------------*)
let get_json_for_manifest 
	(mf_filename : string)
	: bool * Yojson.Basic.json = 

	let retval = ref false in
	let retjson = ref `Null in

	try
		let mf_json = Yojson.Basic.from_file mf_filename in
		retjson := mf_json;
		retval := true;

	with Yojson.Json_error s -> 
		Uberspark_logger.log ~lvl:Uberspark_logger.Error "%s" s;
		retval := false;
	;

	(!retval, !retjson)
;;



(*--------------------------------------------------------------------------*)
(* convert json fields "uberspark.manifest.xxx" into json_node_uberspark_manifest_t variable *)
(* return: *)
(* on success: true; json_node_uberspark_manifest_var fields are modified with parsed values *)
(* on failure: false; json_node_uberspark_manifest_var fields are untouched *)
(*--------------------------------------------------------------------------*)
let json_node_uberspark_manifest_to_var 
	(mf_json : Yojson.Basic.t)
	(json_node_uberspark_manifest_var : json_node_uberspark_manifest_t) 
	: bool =

	let retval = ref false in

	try
		let open Yojson.Basic.Util in
			json_node_uberspark_manifest_var.namespace <- (json_list_to_string_list (mf_json |> member "uberspark.manifest.namespace" |> to_list));
			json_node_uberspark_manifest_var.version_min <- mf_json |> member "uberspark.manifest.version_min" |> to_string;
			json_node_uberspark_manifest_var.version_max <- mf_json |> member "uberspark.manifest.version_max" |> to_string;
			retval := true;

	with Yojson.Basic.Util.Type_error _ -> 
			retval := false;
	;

	(!retval)
;;



(*--------------------------------------------------------------------------*)
(* convert json_node_uberspark_manifest_var to json string *)
(*--------------------------------------------------------------------------*)
let json_node_uberspark_manifest_var_to_jsonstr  
	(json_node_uberspark_manifest_var : json_node_uberspark_manifest_t) 
	: string =
	let retstr = ref "" in


	retstr := !retstr ^ Printf.sprintf  "\n";

	retstr := !retstr ^ Printf.sprintf  "\n\t\"uberspark.manifest.namespace\" : [ ";
	for i = 0 to ((List.length json_node_uberspark_manifest_var.namespace)-1) do
		if i == ((List.length json_node_uberspark_manifest_var.namespace)-1) then begin
			retstr := !retstr ^ Printf.sprintf  "\"%s\"" (List.nth json_node_uberspark_manifest_var.namespace i);
		end else begin
			retstr := !retstr ^ Printf.sprintf  "\"%s,\"" (List.nth json_node_uberspark_manifest_var.namespace i);
		end;
	done;
	retstr := !retstr ^ Printf.sprintf  "],";

	retstr := !retstr ^ Printf.sprintf  "\n\t\"uberspark.manifest.version_min\" : \"%s\"," json_node_uberspark_manifest_var.version_min;
	retstr := !retstr ^ Printf.sprintf  "\n\t\"uberspark.manifest.version_max\" : \"%s\"" json_node_uberspark_manifest_var.version_max;

	retstr := !retstr ^ Printf.sprintf  "\n";

	(!retstr)
;;











(*--------------------------------------------------------------------------*)
(* write manifest prologue *)
(*--------------------------------------------------------------------------*)
let write_prologue 
	?(prologue_str = "uberSpark manifest")
	(oc : out_channel)
	: bool = 
	
	let retval = ref false in

	Printf.fprintf oc "\n/* --- this file is autogenerated --- */";
	Printf.fprintf oc "\n/* %s */" prologue_str;
	Printf.fprintf oc "\n";
	Printf.fprintf oc "\n";
	Printf.fprintf oc "\n{";

	retval := true;

	(!retval)
;;



(*--------------------------------------------------------------------------*)
(* write manifest epilogue *)
(*--------------------------------------------------------------------------*)
let write_epilogue 
	?(epilogue_str = "uberSpark end-of-manifest")
	(oc : out_channel)
	: bool = 
	
	let retval = ref false in

	Printf.fprintf oc "\n";
	Printf.fprintf oc "\n";
	Printf.fprintf oc "\n/* %s */" epilogue_str;
	Printf.fprintf oc "\n";
	Printf.fprintf oc "\n}";

	retval := true;

	(!retval)
;;



(*--------------------------------------------------------------------------*)
(* write given list of json node string representations to manifest file *)
(*--------------------------------------------------------------------------*)
let write_to_file 
	(output_manifest_filename : string)
	(output_jsonstr_list : string list)
	=

	let oc = open_out output_manifest_filename in

	write_prologue oc;

	for i = 0 to ((List.length output_jsonstr_list)-1) do
		if i == ((List.length output_jsonstr_list)-1) then begin
			Printf.fprintf oc "%s" (List.nth output_jsonstr_list i);
		end else begin
			Printf.fprintf oc "%s," (List.nth output_jsonstr_list i);
		end;
	done;

	write_epilogue oc;

	close_out oc;	
;;



(*---------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------*)
(* submodules *)
(*---------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------*)

module Bridge = struct
	#include "uberspark_manifest_bridge.ml"

	module Cc = struct
	#include "uberspark_manifest_bridge_cc.ml"
	end

	module Ld = struct
	#include "uberspark_manifest_bridge_ld.ml"
	end

	module As = struct
	#include "uberspark_manifest_bridge_as.ml"
	end

	module Vf = struct
	#include "uberspark_manifest_bridge_vf.ml"
	end

	module Loader = struct
	#include "uberspark_manifest_bridge_loader.ml"
	end

end


module Config = struct
	#include "uberspark_manifest_config.ml"
end


module Installation = struct
	#include "uberspark_manifest_installation.ml"
end


module Sentinel = struct
	#include "uberspark_manifest_sentinel.ml"
end

module Loader = struct
	#include "uberspark_manifest_loader.ml"
end

module Uobj = struct
	#include "uberspark_manifest_uobj.ml"
end


module Uobjcoll = struct
	#include "uberspark_manifest_uobjcoll.ml"
end


module Uobjslt = struct
	#include "uberspark_manifest_uobjslt.ml"
end

module Uobjrtl = struct
	#include "uberspark_manifest_uobjrtl.ml"
end
