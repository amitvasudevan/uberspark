(*===========================================================================*)
(*===========================================================================*)
(* uberSpark manifest interface implementation *)
(*	 author: amit vasudevan (amitvasudevan@acm.org) *)
(*===========================================================================*)
(*===========================================================================*)

open Yojson


(*---------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------*)
(* type definitions *)
(*---------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------*)

(* uberspark generic manifest header *)
type hdr_t =
{
	mutable f_coss_version : string;			
	mutable f_mftype : string;
	mutable f_uberspark_min_version   : string;
	mutable f_uberspark_max_version   : string;
};;


(* uberspark manifest json node type *)
type json_node_uberspark_manifest_t =
{
	mutable f_manifest_node_types : string list;
	mutable f_uberspark_min_version   : string;
	mutable f_uberspark_max_version   : string;
};;



(*---------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------*)
(* interface definitions *)
(*---------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------*)


let json_list_to_string_list
	json_list = 
	
	let ret_str_list = ref [] in
		List.iter (fun (x) ->
			ret_str_list := !ret_str_list @ [ (Yojson.Basic.Util.to_string x) ];
		) json_list;

	(!ret_str_list)
;;


let json_node_pretty_print_to_string json_node 
	: string =
    (Yojson.Basic.pretty_to_string json_node)
;;


let json_node_update key new_value json_node 
	: (bool * Yojson.Basic.t) =
    let updated = ref false in
    let as_obj = Yojson.Basic.Util.to_assoc json_node in
    let g = List.map begin function
        | (this_key, _inner) when this_key = key -> updated := true; (this_key, new_value)
        | otherwise -> otherwise
      end
        as_obj
    in
    if !updated then (true, `Assoc g) else (false, `Assoc g)
;;


(*--------------------------------------------------------------------------*)
(* parse node: "uberspark-hdr" *)
(* input: manifest json *)
(* return: *)
(* on success: true, manifest header node as hdr_t*)
(* on failure: false *)
(*--------------------------------------------------------------------------*)
let parse_uberspark_hdr 
	(mf_json : Yojson.Basic.t)
	(uberspark_hdr : hdr_t) 
	: bool =

	let retval = ref false in

	try
		let open Yojson.Basic.Util in
			let json_mf_hdr = mf_json |> member "uberspark-hdr" in
			if(json_mf_hdr <> `Null) then
				begin
					uberspark_hdr.f_coss_version <- json_mf_hdr |> member "coss_version" |> to_string;
					uberspark_hdr.f_mftype <- json_mf_hdr |> member "mftype" |> to_string;
					uberspark_hdr.f_uberspark_min_version <- json_mf_hdr |> member "uberspark_min_version" |> to_string;
					uberspark_hdr.f_uberspark_max_version <- json_mf_hdr |> member "uberspark_max_version" |> to_string;
					retval := true;
				end
			;

	with Yojson.Basic.Util.Type_error _ -> 
			retval := false;
	;

	(!retval)
;;


(*--------------------------------------------------------------------------*)
(* read manifest file into json object; sanity checking uberspark version *)
(*--------------------------------------------------------------------------*)
let get_manifest_json 
	?(check_header = true)
	(mf_filename : string)
	: bool * Yojson.Basic.json = 
	let retval = ref false in
	let retjson = ref `Null in

	try

		let mf_json = Yojson.Basic.from_file mf_filename in
		retjson := mf_json;
		retval := true;

		if (check_header) then
		begin
			let mf_hdr : hdr_t = { f_coss_version = ""; f_mftype = ""; f_uberspark_max_version = "";
				f_uberspark_min_version = "";} in
			let mf_hdr_parsed = parse_uberspark_hdr mf_json mf_hdr in
			if (mf_hdr_parsed) then 
				begin
					(* TBD: sanity check header and version *)
					retval := true;
					retjson := mf_json;
				end
			else 
				begin
					Uberspark_logger.log ~lvl:Uberspark_logger.Error "could not find valid header within manifest!";
					retval := false;
					retjson := `Null;
				end
			;
		end
		;

	with Yojson.Json_error s -> 
		Uberspark_logger.log ~lvl:Uberspark_logger.Error "%s" s;
		retval := false;
	;

	(!retval, !retjson)
;;



(*--------------------------------------------------------------------------*)
(* convert json node "uberspark-manifest" into json_node_uberspark_manifest_t variable *)
(* return: *)
(* on success: true; json_node_uberspark_manifest_var fields are modified with parsed values *)
(* on failure: false; json_node_uberspark_manifest_var fields are untouched *)
(*--------------------------------------------------------------------------*)
let json_node_uberspark_manifest_to_var 
	(manifest_json : Yojson.Basic.t)
	(json_node_uberspark_manifest_var : json_node_uberspark_manifest_t) 
	: bool =

	let retval = ref false in

	try
		let open Yojson.Basic.Util in
			let l_json_node_uberspark_manifest = manifest_json |> member "uberspark-manifest" in
			if(l_json_node_uberspark_manifest <> `Null) then
				begin
					json_node_uberspark_manifest_var.f_manifest_node_types <- (json_list_to_string_list (l_json_node_uberspark_manifest |> member "manifest_node_types" |> to_list));
					json_node_uberspark_manifest_var.f_uberspark_min_version <- l_json_node_uberspark_manifest |> member "uberspark_min_version" |> to_string;
					json_node_uberspark_manifest_var.f_uberspark_max_version <- l_json_node_uberspark_manifest |> member "uberspark_max_version" |> to_string;
					retval := true;
				end
			;

	with Yojson.Basic.Util.Type_error _ -> 
			retval := false;
	;

	(!retval)
;;




(*--------------------------------------------------------------------------*)
(* read manifest file and return json object of specified manifest node type *)
(* return null if the node type is not found in the manifest *)
(*--------------------------------------------------------------------------*)
let get_json_for_manifest_node_type 
	(manifest_filename : string)
	(manifest_node_type : string)
	: bool * Yojson.Basic.json * Yojson.Basic.json = 

	let retval = ref false in
	let retjson_uberspark_manifest = ref `Null in
	let retjson = ref `Null in

	try

		let manifest_json = Yojson.Basic.from_file manifest_filename in
		let json_node_uberspark_manifest : json_node_uberspark_manifest_t = 
			{ 	f_manifest_node_types = []; 
				f_uberspark_max_version = "";
				f_uberspark_min_version = "";} in
		let rval_uberspark_manifest_node_parsed = json_node_uberspark_manifest_to_var manifest_json json_node_uberspark_manifest in

		if 	rval_uberspark_manifest_node_parsed = true then begin

			if (List.mem manifest_node_type json_node_uberspark_manifest.f_manifest_node_types) then begin
				retjson := (Yojson.Basic.Util.member manifest_node_type manifest_json);
				retjson_uberspark_manifest := (Yojson.Basic.Util.member Uberspark_namespace.namespace_root_mf_node_type_tag manifest_json);
				retval := true;
			end else begin
				Uberspark_logger.log ~lvl:Uberspark_logger.Error "manifest node type '%s' is not listed within uberspark-manifest node within manifest!";
				retjson := `Null;
				retjson_uberspark_manifest := `Null;
				retval := false;
			end;

		end else begin
			Uberspark_logger.log ~lvl:Uberspark_logger.Error "could not find valid header within manifest!";
			retjson := `Null;
			retjson_uberspark_manifest := `Null;
			retval := false;

		end;	
		
	with Yojson.Json_error s -> 
		Uberspark_logger.log ~lvl:Uberspark_logger.Error "%s" s;
		retjson_uberspark_manifest := `Null;
		retjson := `Null;
		retval := false;
	;

	(!retval, !retjson_uberspark_manifest, !retjson)
;;








(*--------------------------------------------------------------------------*)
(* write manifest prologue *)
(*--------------------------------------------------------------------------*)
let write_prologue 
	?(prologue_str = "uberSpark manifest")
	(oc : out_channel)
	: bool = 
	
	let retval = ref false in

	Printf.fprintf oc "\n/* --- this file is autogenerated --- */";
	Printf.fprintf oc "\n/* %s */" prologue_str;
	Printf.fprintf oc "\n";
	Printf.fprintf oc "\n";
	Printf.fprintf oc "\n{";

	retval := true;

	(!retval)
;;


(*--------------------------------------------------------------------------*)
(* write uberspark-hdr manifest node *)
(*--------------------------------------------------------------------------*)
let write_uberspark_hdr 
	?(continuation = true)
	(oc : out_channel)
	(uberspark_hdr : hdr_t)
	: bool = 
	
	let retval = ref false in

	Printf.fprintf oc "\n";
	Printf.fprintf oc "\n\t\"uberspark-hdr\":{";
	Printf.fprintf oc "\n\t\t\"coss_version\" : \"%s\"," uberspark_hdr.f_coss_version;
	Printf.fprintf oc "\n\t\t\"mftype\" : \"%s\"," uberspark_hdr.f_mftype;
	Printf.fprintf oc "\n\t\t\"uberspark_min_version\" : \"%s\"," uberspark_hdr.f_uberspark_min_version;
	Printf.fprintf oc "\n\t\t\"uberspark_max_version\" : \"%s\"" uberspark_hdr.f_uberspark_max_version;

	if continuation then
		begin
			Printf.fprintf oc "\n\t},";
		end
	else
		begin
			Printf.fprintf oc "\n\t}";
		end
	;

	Printf.fprintf oc "\n";

	retval := true;

	(!retval)
;;



(*--------------------------------------------------------------------------*)
(* write manifest epilogue *)
(*--------------------------------------------------------------------------*)
let write_epilogue 
	?(epilogue_str = "uberSpark end-of-manifest")
	(oc : out_channel)
	: bool = 
	
	let retval = ref false in

	Printf.fprintf oc "\n";
	Printf.fprintf oc "\n";
	Printf.fprintf oc "\n/* %s */" epilogue_str;
	Printf.fprintf oc "\n";
	Printf.fprintf oc "\n}";

	retval := true;

	(!retval)
;;




(*---------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------*)
(* submodules *)
(*---------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------*)

module Bridge =
struct
#include "uberspark_manifest_bridge.ml"
end


module Config =
struct
#include "uberspark_manifest_config.ml"
end

module Uobj =
struct
#include "uberspark_manifest_uobj.ml"
end

module Uobjcoll =
struct
#include "uberspark_manifest_uobjcoll.ml"
end

module Uobjslt =
struct
#include "uberspark_manifest_uobjslt.ml"
end

module Sentinel =
struct
#include "uberspark_manifest_sentinel.ml"
end
