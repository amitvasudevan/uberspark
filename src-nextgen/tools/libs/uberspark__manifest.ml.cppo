(*===========================================================================*)
(*===========================================================================*)
(* uberSpark manifest interface implementation *)
(*	 author: amit vasudevan (amitvasudevan@acm.org) *)
(*===========================================================================*)
(*===========================================================================*)

open Yojson


(*---------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------*)
(* type definitions *)
(*---------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------*)


type json_node_uberspark_manifest_actions_t = 
{
	mutable targets : string list;
	mutable name : string;
	mutable category : string;

	(* if category == translation *)
	mutable input : string list;
	mutable output : string list;
	mutable bridge_namespace: string; 
	mutable bridge_cmd : string list; 
	
	(* if category == uobjaction *)
	mutable uobj_namespace : string; 

	(* if category == uobjrtl_action *)
	mutable uobjrtl_namespace : string; 

	(* if category == loader_action *)
	mutable loader_namespace : string; 

};;


(* uberspark manifest json node type *)
type json_node_uberspark_manifest_t =
{
	mutable namespace : string;
	mutable version_min   : string;
	mutable version_max   : string;
	mutable actions : json_node_uberspark_manifest_actions_t list;
};;



(*---------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------*)
(* interface definitions *)
(*---------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------*)


let json_list_to_string_list
	json_list = 
	
	let ret_str_list = ref [] in
		List.iter (fun (x) ->
			ret_str_list := !ret_str_list @ [ (Yojson.Basic.Util.to_string x) ];
		) json_list;

	(!ret_str_list)
;;


let json_node_pretty_print_to_string json_node 
	: string =
    (Yojson.Basic.pretty_to_string json_node)
;;


let json_node_update key new_value json_node 
	: (bool * Yojson.Basic.t) =
    let updated = ref false in
    let as_obj = Yojson.Basic.Util.to_assoc json_node in
    let g = List.map begin function
        | (this_key, _inner) when this_key = key -> updated := true; (this_key, new_value)
        | otherwise -> otherwise
      end
        as_obj
    in
    if !updated then (true, `Assoc g) else (false, `Assoc g)
;;





(*--------------------------------------------------------------------------*)
(* read manifest file into json *)
(* note: this does not check if this is a valid uberspark manifest; only checked *)
(* if it is a valid json file *)
(*--------------------------------------------------------------------------*)
let get_json_for_manifest 
	(mf_filename : string)
	: bool * Yojson.Basic.json = 

	let retval = ref false in
	let retjson = ref `Null in

	try
		let mf_json = Yojson.Basic.from_file mf_filename in
		retjson := mf_json;
		retval := true;

	with Yojson.Json_error s -> 
		Uberspark.Logger.log ~lvl:Uberspark.Logger.Error "%s" s;
		retval := false;
	;

	(!retval, !retjson)
;;



(*--------------------------------------------------------------------------*)
(* parse manifest json sub-node "uberspark.manifest.actions" into var *)
(* return: *)
(* on success: true; var is modified with actions declarations *)
(* on failure: false; var is unmodified *)
(*--------------------------------------------------------------------------*)
let json_node_uberspark_manifest_actions_to_var
	(mf_json : Yojson.Basic.t)
	: bool *  (json_node_uberspark_manifest_actions_t list)
=
		
	let retval = ref true in
	let actions_list : json_node_uberspark_manifest_actions_t list ref = ref [] in 

	try
		let open Yojson.Basic.Util in
			let uberspark_manifest_actions_json = mf_json |> member "uberspark.manifest.actions" in
				if uberspark_manifest_actions_json != `Null then
					begin

						let actions_json_list = Yojson.Basic.Util.to_list uberspark_manifest_actions_json in
							
							List.iter (fun (l_actions_json : Yojson.Basic.t) ->
								let actions_entry : json_node_uberspark_manifest_actions_t = {
									targets = []; name = ""; category = "";
									input = []; output = []; bridge_namespace = ""; bridge_cmd = [];
									uobj_namespace = "";
									uobjrtl_namespace = "";
									loader_namespace = "";
								} in

								if (l_actions_json |> member "targets") <> `Null then 
									actions_entry.targets <- json_list_to_string_list (l_actions_json |> member "targets" |> to_list);

								if (l_actions_json |> member "name") <> `Null then 
									actions_entry.name <- (l_actions_json |> member "name" |> to_string);

								if (l_actions_json |> member "category") <> `Null then 
									actions_entry.category <- (l_actions_json |> member "category" |> to_string);

								if (l_actions_json |> member "input") <> `Null then 
									actions_entry.input <- json_list_to_string_list (l_actions_json |> member "input" |> to_list);

								if (l_actions_json |> member "output") <> `Null then 
									actions_entry.output <- json_list_to_string_list (l_actions_json |> member "output" |> to_list);

								if (l_actions_json |> member "bridge_namespace") <> `Null then 
									actions_entry.bridge_namespace <- (l_actions_json |> member "bridge_namespace" |> to_string);

								if (l_actions_json |> member "bridge_cmd") <> `Null then 
									actions_entry.bridge_cmd <- json_list_to_string_list (l_actions_json |> member "bridge_cmd" |> to_list);

								if (l_actions_json |> member "uobj_namespace") <> `Null then 
									actions_entry.uobj_namespace <- (l_actions_json |> member "uobj_namespace" |> to_string);

								if (l_actions_json |> member "uobjrtl_namespace") <> `Null then 
									actions_entry.uobj_namespace <- (l_actions_json |> member "uobjrtl_namespace" |> to_string);

								if (l_actions_json |> member "loader_namespace") <> `Null then 
									actions_entry.loader_namespace <- (l_actions_json |> member "loader_namespace" |> to_string);

								actions_list := !actions_list @ [ actions_entry ];
					
								()
							) actions_json_list;

					end
				;
														
	with Yojson.Basic.Util.Type_error _ -> 
			retval := false;
	;

							
	(!retval, !actions_list)
;;




(*--------------------------------------------------------------------------*)
(* convert json fields "uberspark.manifest.xxx" into json_node_uberspark_manifest_t variable *)
(* return: *)
(* on success: true; json_node_uberspark_manifest_var fields are modified with parsed values *)
(* on failure: false; json_node_uberspark_manifest_var fields are untouched *)
(*--------------------------------------------------------------------------*)
let json_node_uberspark_manifest_to_var 
	(mf_json : Yojson.Basic.t)
	(json_node_uberspark_manifest_var : json_node_uberspark_manifest_t) 
	: bool =

	let retval = ref false in

	try
		let open Yojson.Basic.Util in
			json_node_uberspark_manifest_var.namespace <- mf_json |> member "uberspark.manifest.namespace" |> to_string;
	
			if (mf_json |> member "uberspark.manifest.version_min") <> `Null then 
				json_node_uberspark_manifest_var.version_min <- mf_json |> member "uberspark.manifest.version_min" |> to_string;
	
			if (mf_json |> member "uberspark.manifest.version_max") <> `Null then 
				json_node_uberspark_manifest_var.version_max <- mf_json |> member "uberspark.manifest.version_max" |> to_string;

			let (rval1, json_node_uberspark_manifest_actions_var) = (json_node_uberspark_manifest_actions_to_var mf_json) in

			if rval1 then begin
				json_node_uberspark_manifest_var.actions <- json_node_uberspark_manifest_actions_var;
			end;


			retval := true;

	with Yojson.Basic.Util.Type_error _ -> 
			retval := false;
	;

	(!retval)
;;



(*--------------------------------------------------------------------------*)
(* convert json_node_uberspark_manifest_var to json string *)
(*--------------------------------------------------------------------------*)
let json_node_uberspark_manifest_var_to_jsonstr  
	(json_node_uberspark_manifest_var : json_node_uberspark_manifest_t) 
	: string =
	let retstr = ref "" in


	retstr := !retstr ^ Printf.sprintf  "\n";


	retstr := !retstr ^ Printf.sprintf  "\n\t\"uberspark.manifest.namespace\" : \"%s\"," json_node_uberspark_manifest_var.namespace;
	retstr := !retstr ^ Printf.sprintf  "\n\t\"uberspark.manifest.version_min\" : \"%s\"," json_node_uberspark_manifest_var.version_min;
	retstr := !retstr ^ Printf.sprintf  "\n\t\"uberspark.manifest.version_max\" : \"%s\"" json_node_uberspark_manifest_var.version_max;

	retstr := !retstr ^ Printf.sprintf  "\n";

	(!retstr)
;;











(*--------------------------------------------------------------------------*)
(* write manifest prologue *)
(*--------------------------------------------------------------------------*)
let write_prologue 
	?(prologue_str = "uberSpark manifest")
	(oc : out_channel)
	: bool = 
	
	let retval = ref false in

	Printf.fprintf oc "\n/* --- this file is autogenerated --- */";
	Printf.fprintf oc "\n/* %s */" prologue_str;
	Printf.fprintf oc "\n";
	Printf.fprintf oc "\n";
	Printf.fprintf oc "\n{";

	retval := true;

	(!retval)
;;



(*--------------------------------------------------------------------------*)
(* write manifest epilogue *)
(*--------------------------------------------------------------------------*)
let write_epilogue 
	?(epilogue_str = "uberSpark end-of-manifest")
	(oc : out_channel)
	: bool = 
	
	let retval = ref false in

	Printf.fprintf oc "\n";
	Printf.fprintf oc "\n";
	Printf.fprintf oc "\n/* %s */" epilogue_str;
	Printf.fprintf oc "\n";
	Printf.fprintf oc "\n}";

	retval := true;

	(!retval)
;;



(*--------------------------------------------------------------------------*)
(* write given list of json node string representations to manifest file *)
(*--------------------------------------------------------------------------*)
let write_to_file 
	(output_manifest_filename : string)
	(output_jsonstr_list : string list)
	=

	let oc = open_out output_manifest_filename in

	write_prologue oc;

	for i = 0 to ((List.length output_jsonstr_list)-1) do
		if i == ((List.length output_jsonstr_list)-1) then begin
			Printf.fprintf oc "%s" (List.nth output_jsonstr_list i);
		end else begin
			Printf.fprintf oc "%s," (List.nth output_jsonstr_list i);
		end;
	done;

	write_epilogue oc;

	close_out oc;	
;;



(*---------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------*)
(* submodules *)
(*---------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------*)

module Bridge = struct
	#include "uberspark__manifest_bridge.ml"
end


module Platform = struct
	#include "uberspark__manifest_platform.ml"
end


module Installation = struct
	#include "uberspark__manifest_installation.ml"
end


module Sentinel = struct
	#include "uberspark__manifest_sentinel.ml"
end

module Loader = struct
	#include "uberspark__manifest_loader.ml"
end

module Uobj = struct
	#include "uberspark__manifest_uobj.ml"
end


module Uobjcoll = struct
	#include "uberspark__manifest_uobjcoll.ml"
end


module Uobjslt = struct
	#include "uberspark__manifest_uobjslt.ml"
end

module Uobjrtl = struct
	#include "uberspark__manifest_uobjrtl.ml"
end


(*---------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------*)
(* type definitions *)
(*---------------------------------------------------------------------------*)
(*---------------------------------------------------------------------------*)

(* uberspark manifest variable type *)
(* represents a mapping between a manifest JSON and corresponding ocaml variables *)
(* manifest JSON node uberspark.manifest.xxx is accessible as mf_var.manifest.xxx *)
(* where mf_var is of type uberspark_manifest_var_t *)

type uberspark_manifest_var_t =
{
	mutable manifest : json_node_uberspark_manifest_t;
	mutable uobjcoll : Uobjcoll.json_node_uberspark_uobjcoll_t;
	mutable uobj : Uobj.json_node_uberspark_uobj_t;
	mutable uobjrtl : Uobjrtl.json_node_uberspark_uobjrtl_t;
	mutable sentinel : Sentinel.json_node_uberspark_sentinel_t; 
	mutable loader : Loader.json_node_uberspark_loader_t; 
	mutable platform : Platform.json_node_uberspark_platform_t; 
};;

(*--------------------------------------------------------------------------*)
(* convert manifest json fields into uberspark_manifest_var_t variable *)
(* return: *)
(* on success: true; uberspark_manifest_var_t fields are modified with parsed values *)
(* on failure: false; uberspark_manifest_var_t fields are untouched *)
(*--------------------------------------------------------------------------*)
let manifest_json_to_uberspark_manifest_var 
	?(p_only_configurable = false)
	(mf_json : Yojson.Basic.t)
	(uberspark_manifest_var : uberspark_manifest_var_t) 
	: bool =

	let retval = ref false in

	try
		let open Yojson.Basic.Util in
			
			let rval_1 = (json_node_uberspark_manifest_to_var mf_json uberspark_manifest_var.manifest) in
			let rval_2 = (Uobjcoll.json_node_uberspark_uobjcoll_to_var mf_json uberspark_manifest_var.uobjcoll) in
			let rval_3 = (Uobj.json_node_uberspark_uobj_to_var mf_json uberspark_manifest_var.uobj) in
			let rval_4 = (Uobjrtl.json_node_uberspark_uobjrtl_to_var mf_json uberspark_manifest_var.uobjrtl) in
			let rval_5 = (Sentinel.json_node_uberspark_sentinel_to_var mf_json uberspark_manifest_var.sentinel) in
			let rval_6 = (Loader.json_node_uberspark_loader_to_var mf_json uberspark_manifest_var.loader) in
			let rval_7 = (Platform.json_node_uberspark_platform_to_var ~p_only_configurable:p_only_configurable mf_json uberspark_manifest_var.platform) in
	
			if (rval_1 && rval_2 && rval_3 && rval_4 && rval_5 && rval_6 && rval_7) then begin
				retval:=true
			end;
			
	with Yojson.Basic.Util.Type_error _ -> 
			retval := false;
	;

	(!retval)
;;


(*--------------------------------------------------------------------------*)
(* read manifest file, convert manifest json fields into uberspark_manifest_var_t variable *)
(* return: *)
(* on success: true; uberspark_manifest_var_t fields are modified with parsed values *)
(* on failure: false; uberspark_manifest_var_t fields are untouched *)
(*--------------------------------------------------------------------------*)
let manifest_file_to_uberspark_manifest_var 
	?(p_only_configurable = false)
	(abspath_mf_filename : string)
	(uberspark_manifest_var : uberspark_manifest_var_t) 
	: bool * Yojson.Basic.t =

	let retval = ref false in
	let l_mf_json = ref `Null in 

	try
		l_mf_json := Yojson.Basic.from_file abspath_mf_filename;
		retval := manifest_json_to_uberspark_manifest_var ~p_only_configurable:p_only_configurable !l_mf_json uberspark_manifest_var;

	with Yojson.Json_error s -> 
		Uberspark.Logger.log ~lvl:Uberspark.Logger.Error "%s" s;
		retval := false;
	;

	(!retval, !l_mf_json)
;;


(* copy constructor for  manifest variable definition *)
(* we use this to copy one manifest variable into another *)
let uberspark_manifest_var_copy 
	(output : uberspark_manifest_var_t)
	(input : uberspark_manifest_var_t)
	: unit = 
	Uberspark.Logger.log ~lvl:Uberspark.Logger.Debug "copy constructor: %s" input.manifest.namespace;

	output.manifest.namespace <- input.manifest.namespace; 
	output.manifest.version_min <- input.manifest.version_min; 
	output.manifest.version_max <- input.manifest.version_max;
	output.manifest.actions <- input.manifest.actions;


	output.uobjcoll.namespace <- input.uobjcoll.namespace; 
	output.uobjcoll.platform <- input.uobjcoll.platform; 
	output.uobjcoll.arch <- input.uobjcoll.arch; 
	output.uobjcoll.cpu <- input.uobjcoll.cpu ; 
	output.uobjcoll.hpl <- input.uobjcoll.hpl;
	output.uobjcoll.sentinels_intra_uobjcoll <- input.uobjcoll.sentinels_intra_uobjcoll;
	output.uobjcoll.uobjs.master <- input.uobjcoll.uobjs.master; 
	output.uobjcoll.uobjs.templars <- input.uobjcoll.uobjs.templars;
	output.uobjcoll.init_method.uobj_namespace <- input.uobjcoll.init_method.uobj_namespace; 
	output.uobjcoll.init_method.public_method <- input.uobjcoll.init_method.public_method; 
	output.uobjcoll.init_method.sentinels <- input.uobjcoll.init_method.sentinels;
	output.uobjcoll.public_methods <- input.uobjcoll.public_methods;
	output.uobjcoll.loaders <- input.uobjcoll.loaders;
	output.uobjcoll.configdefs_verbatim <- input.uobjcoll.configdefs_verbatim;
	output.uobjcoll.configdefs <- input.uobjcoll.configdefs;
	output.uobjcoll.sources <- input.uobjcoll.sources;


	output.uobj.namespace <- input.uobj.namespace; 
	output.uobj.platform <- input.uobj.platform; 
	output.uobj.arch <- input.uobj.arch; 
	output.uobj.cpu <- input.uobj.cpu; 
	(*
	output.uobj.sources.source_h_files<- input.uobj.sources.source_h_files; 
	output.uobj.sources.source_c_files <- input.uobj.sources.source_c_files; 
	output.uobj.sources.source_casm_files <- input.uobj.sources.source_casm_files; 
	output.uobj.sources.source_asm_files <- input.uobj.sources.source_asm_files;
	*)
	output.uobj.sources <- input.uobj.sources;
	output.uobj.headers <- input.uobj.headers;

	output.uobj.public_methods <- input.uobj.public_methods; 
	output.uobj.intra_uobjcoll_callees <- input.uobj.intra_uobjcoll_callees; 
	output.uobj.inter_uobjcoll_callees <- input.uobj.inter_uobjcoll_callees;
	output.uobj.legacy_callees <- input.uobj.legacy_callees; 
	output.uobj.sections <- input.uobj.sections; 
	output.uobj.uobjrtl <- input.uobj.uobjrtl; 

	output.uobjrtl.namespace <- input.uobjrtl.namespace; 
	output.uobjrtl.platform <- input.uobjrtl.platform; 
	output.uobjrtl.arch <- input.uobjrtl.arch; 
	output.uobjrtl.cpu <- input.uobjrtl.cpu; 
	output.uobjrtl.sources <- input.uobjrtl.sources; 
	
	output.sentinel.namespace <- input.sentinel.namespace; 
	output.sentinel.platform <- input.sentinel.platform; 
	output.sentinel.arch <- input.sentinel.arch; 
	output.sentinel.cpu <- input.sentinel.cpu; 
	output.sentinel.sizeof_code_template <- input.sentinel.sizeof_code_template; 
	output.sentinel.code_template <- input.sentinel.code_template; 
	output.sentinel.library_code_template <- input.sentinel.library_code_template;

	output.loader.namespace <- input.loader.namespace; 
	output.loader.platform <- input.loader.platform; 
	output.loader.arch <- input.loader.arch; 
	output.loader.cpu <- input.loader.cpu; 
	output.loader.bridge_namespace <- input.loader.bridge_namespace; 
	output.loader.bridge_cmd <- input.loader.bridge_cmd; 

	Platform.json_node_uberspark_platform_var_copy output.platform input.platform;

(*	
	output.platform.binary.page_size 								<- 	input.platform.binary.page_size 							;
	output.platform.binary.uobj_section_alignment 					<- 	input.platform.binary.uobj_section_alignment 				;
	output.platform.binary.uobj_default_section_size 				<- 	input.platform.binary.uobj_default_section_size 			;
	output.platform.binary.uobj_image_load_address 					<- 	input.platform.binary.uobj_image_load_address 				;
	output.platform.binary.uobj_image_uniform_size 					<- 	input.platform.binary.uobj_image_uniform_size 				;
	output.platform.binary.uobj_image_size 							<- 	input.platform.binary.uobj_image_size 						;
	output.platform.binary.uobj_image_alignment 					<- 	input.platform.binary.uobj_image_alignment 				;
	output.platform.binary.uobjcoll_image_load_address 				<- 	input.platform.binary.uobjcoll_image_load_address 			;
	output.platform.binary.uobjcoll_image_hdr_section_alignment 	<- 	input.platform.binary.uobjcoll_image_hdr_section_alignment ;
	output.platform.binary.uobjcoll_image_hdr_section_size 			<- 	input.platform.binary.uobjcoll_image_hdr_section_size 		;
	output.platform.binary.uobjcoll_image_section_alignment 		<- 	input.platform.binary.uobjcoll_image_section_alignment 	;
	output.platform.binary.uobjcoll_image_size 						<- 	input.platform.binary.uobjcoll_image_size 					;
	output.platform.bridges.cc_bridge_namespace 					<- 	input.platform.bridges.cc_bridge_namespace 				;
	output.platform.bridges.as_bridge_namespace 					<- 	input.platform.bridges.as_bridge_namespace 				;
	output.platform.bridges.casm_bridge_namespace 					<- 	input.platform.bridges.casm_bridge_namespace 				;
	output.platform.bridges.ld_bridge_namespace 					<- 	input.platform.bridges.ld_bridge_namespace 				;
	output.platform.bridges.uberspark_vf_bridge_namespace 			<- 	input.platform.bridges.uberspark_vf_bridge_namespace 		;
*)

	()
;;


(* default manifest variable definition *)
(* we use this to initialize manifest variables *)
let uberspark_manifest_var_default_value () 
	: uberspark_manifest_var_t = 
	{
	manifest = {
		namespace = ""; 
		version_min = "any"; 
		version_max = "any";
		actions = [];
	};
	uobjcoll = {
		namespace = ""; platform = ""; arch = ""; cpu = ""; hpl = "";
		sentinels_intra_uobjcoll = [];
		uobjs = { master = ""; templars = [];};
		init_method = {uobj_namespace = ""; public_method = ""; sentinels = [];};
		public_methods = [];
		loaders = [];
		configdefs_verbatim = false;
		configdefs = [];
		sources = [];
	};
	uobj = {namespace = ""; platform = ""; arch = ""; cpu = ""; 
		sources = []; headers = [];
		public_methods = []; intra_uobjcoll_callees = []; inter_uobjcoll_callees = [];
		legacy_callees = []; sections = []; uobjrtl = []; 
		};
	uobjrtl = {namespace = ""; platform = ""; arch = ""; cpu = ""; 
		sources = [];
		};

	sentinel ={namespace = ""; platform = ""; arch = ""; cpu = ""; 
		sizeof_code_template = 0; code_template = ""; library_code_template = "";
		}; 

	loader ={namespace = ""; platform = ""; arch = ""; cpu = ""; 
		bridge_namespace = ""; bridge_cmd = [];
		}; 

(*
	platform ={
		binary = {
			page_size = 0;
			uobj_section_alignment = 0;
			uobj_default_section_size = 0;
			uobj_image_load_address = 0;
			uobj_image_uniform_size = true;
			uobj_image_size = 0;
			uobj_image_alignment = 0;
			uobjcoll_image_load_address = 0;
			uobjcoll_image_hdr_section_alignment = 0;
			uobjcoll_image_hdr_section_size = 0;
			uobjcoll_image_section_alignment = 0;
			uobjcoll_image_size = 0;
		};
		bridges = {
			cc_bridge_namespace = "";
			as_bridge_namespace = "";
			casm_bridge_namespace = "";
			ld_bridge_namespace = "";
			uberspark_vf_bridge_namespace = "";
		};
	};
*)

	platform = Platform.json_node_uberspark_platform_var_default_value ();

};;
